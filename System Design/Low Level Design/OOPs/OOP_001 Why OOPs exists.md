***TAGS***: #lld #systemdesign #oops

**OOP (Object-Oriented Programming)** exists to make **software easier to design, understand, maintain, and scale** as programs grow in size and complexity.

---
## The problem OOP tries to solve

Early programs were written as long sequences of instructions and functions. As software grew:
- Code became **hard to understand**
- Changes in one place **broke other parts**
- Reusing code was difficult
- Large teams struggled to work on the same codebase
OOP was created to **manage complexity** by modeling software the way we think about the real world.

---
## Core reason OOP exists

 **To organize code around “objects” that bundle data + behavior together.**

Instead of thinking:
> “What functions do I call?”
You think:
> “What objects exist, and what can they do?”

---

## Key goals of OOP (the “why”)
### 1. **Encapsulation – control complexity**

- Data and methods are wrapped together
- Internal details are hidden
- Objects expose only what’s necessary

**Why it matters:**  
You can change the internal implementation without breaking the rest of the program.

---
### 2. **Abstraction – reduce mental load**
- You work with _what_ an object does, not _how_ it does it
**Why it matters:**  
Just like driving a car without knowing engine mechanics, developers can use components without understanding their internals.

---

### 3. **Reusability – avoid rewriting code**

- Classes can be reused across projects
- Inheritance and composition enable extension
**Why it matters:**  
Less code, fewer bugs, faster development.

---

### 4. **Maintainability – easier changes**

- Code is modular
    
- Changes are localized
    

**Why it matters:**  
Large applications evolve constantly. OOP makes change safer.

---

### 5. **Scalability – support large systems & teams**

- Clear responsibilities per object
    
- Easier collaboration
    

**Why it matters:**  
Most real-world software is built by teams, not individuals.

---

## Real-world analogy

Think of a **TV remote**:

- You press buttons (methods)
    
- You don’t see the circuitry (data)
    
- The interface stays the same even if internals change
    

That’s OOP in action.

---

## Why OOP still matters today

Even with functional and procedural programming:

- **Enterprise systems** use OOP heavily
    
- Popular languages (Java, C++, C#, Python) support it
    
- Most design patterns are OOP-based
    

OOP isn’t always the best tool—but it’s a **powerful way to manage complexity**.

---

## One-line summary

> **OOP exists to manage complexity by organizing software around objects that mirror real-world entities, making large systems easier to build, understand, and maintain.**

### Four pillars of OOPs:
- [[OOP_002_Abstraction]]
- [[OOP_003_Encapsulation]]
- [[Inheritance]]
- [[Polymorphism]]
