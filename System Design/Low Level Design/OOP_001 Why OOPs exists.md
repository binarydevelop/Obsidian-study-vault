***TAGS***: #lld #systemdesign #oops

**OOP (Object-Oriented Programming)** exists to make **software easier to design, understand, maintain, and scale** as programs grow in size and complexity.

Hereâ€™s the idea step by step.

---
## The problem OOP tries to solve

Early programs were written as long sequences of instructions and functions. As software grew:

- Code became **hard to understand**
    
- Changes in one place **broke other parts**
    
- Reusing code was difficult
    
- Large teams struggled to work on the same codebase
    

OOP was created to **manage complexity** by modeling software the way we think about the real world.

---

## Core reason OOP exists

ðŸ‘‰ **To organize code around â€œobjectsâ€ that bundle data + behavior together.**

Instead of thinking:

> â€œWhat functions do I call?â€

You think:

> â€œWhat objects exist, and what can they do?â€

---

## Key goals of OOP (the â€œwhyâ€)

### 1. **Encapsulation â€“ control complexity**

- Data and methods are wrapped together
    
- Internal details are hidden
    
- Objects expose only whatâ€™s necessary
    

**Why it matters:**  
You can change the internal implementation without breaking the rest of the program.

---

### 2. **Abstraction â€“ reduce mental load**

- You work with _what_ an object does, not _how_ it does it
    

**Why it matters:**  
Just like driving a car without knowing engine mechanics, developers can use components without understanding their internals.

---

### 3. **Reusability â€“ avoid rewriting code**

- Classes can be reused across projects
    
- Inheritance and composition enable extension
    

**Why it matters:**  
Less code, fewer bugs, faster development.

---

### 4. **Maintainability â€“ easier changes**

- Code is modular
    
- Changes are localized
    

**Why it matters:**  
Large applications evolve constantly. OOP makes change safer.

---

### 5. **Scalability â€“ support large systems & teams**

- Clear responsibilities per object
    
- Easier collaboration
    

**Why it matters:**  
Most real-world software is built by teams, not individuals.

---

## Real-world analogy

Think of a **TV remote**:

- You press buttons (methods)
    
- You donâ€™t see the circuitry (data)
    
- The interface stays the same even if internals change
    

Thatâ€™s OOP in action.

---

## Why OOP still matters today

Even with functional and procedural programming:

- **Enterprise systems** use OOP heavily
    
- Popular languages (Java, C++, C#, Python) support it
    
- Most design patterns are OOP-based
    

OOP isnâ€™t always the best toolâ€”but itâ€™s a **powerful way to manage complexity**.

---

## One-line summary

> **OOP exists to manage complexity by organizing software around objects that mirror real-world entities, making large systems easier to build, understand, and maintain.**

### Four pillars of OOPs:
- [[Abstraction]]
- [[Encapsulation]]
- [[Inheritance]]
- [[Polymorphism]]
